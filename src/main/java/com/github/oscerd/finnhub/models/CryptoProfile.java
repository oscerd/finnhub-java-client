/*
 * Finnhub API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.github.oscerd.finnhub.models;

import java.util.Objects;

import com.google.gson.annotations.SerializedName;
import io.swagger.v3.oas.annotations.media.Schema;

/**
 * CryptoProfile
 */

@jakarta.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2024-03-22T10:38:13.551248835+01:00[Europe/Rome]")

public class CryptoProfile {
  @SerializedName("longName")
  private String longName = null;

  @SerializedName("name")
  private String name = null;

  @SerializedName("description")
  private String description = null;

  @SerializedName("website")
  private String website = null;

  @SerializedName("marketCap")
  private Float marketCap = null;

  @SerializedName("totalSupply")
  private Float totalSupply = null;

  @SerializedName("maxSupply")
  private Float maxSupply = null;

  @SerializedName("circulatingSupply")
  private Float circulatingSupply = null;

  @SerializedName("logo")
  private String logo = null;

  @SerializedName("launchDate")
  private String launchDate = null;

  @SerializedName("proofType")
  private String proofType = null;

  public CryptoProfile longName(String longName) {
    this.longName = longName;
    return this;
  }

   /**
   * Long name.
   * @return longName
  **/
  @Schema(description = "Long name.")
  public String getLongName() {
    return longName;
  }

  public void setLongName(String longName) {
    this.longName = longName;
  }

  public CryptoProfile name(String name) {
    this.name = name;
    return this;
  }

   /**
   * Name.
   * @return name
  **/
  @Schema(description = "Name.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public CryptoProfile description(String description) {
    this.description = description;
    return this;
  }

   /**
   * Description.
   * @return description
  **/
  @Schema(description = "Description.")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public CryptoProfile website(String website) {
    this.website = website;
    return this;
  }

   /**
   * Project&#x27;s website.
   * @return website
  **/
  @Schema(description = "Project's website.")
  public String getWebsite() {
    return website;
  }

  public void setWebsite(String website) {
    this.website = website;
  }

  public CryptoProfile marketCap(Float marketCap) {
    this.marketCap = marketCap;
    return this;
  }

   /**
   * Market capitalization.
   * @return marketCap
  **/
  @Schema(description = "Market capitalization.")
  public Float getMarketCap() {
    return marketCap;
  }

  public void setMarketCap(Float marketCap) {
    this.marketCap = marketCap;
  }

  public CryptoProfile totalSupply(Float totalSupply) {
    this.totalSupply = totalSupply;
    return this;
  }

   /**
   * Total supply.
   * @return totalSupply
  **/
  @Schema(description = "Total supply.")
  public Float getTotalSupply() {
    return totalSupply;
  }

  public void setTotalSupply(Float totalSupply) {
    this.totalSupply = totalSupply;
  }

  public CryptoProfile maxSupply(Float maxSupply) {
    this.maxSupply = maxSupply;
    return this;
  }

   /**
   * Max supply.
   * @return maxSupply
  **/
  @Schema(description = "Max supply.")
  public Float getMaxSupply() {
    return maxSupply;
  }

  public void setMaxSupply(Float maxSupply) {
    this.maxSupply = maxSupply;
  }

  public CryptoProfile circulatingSupply(Float circulatingSupply) {
    this.circulatingSupply = circulatingSupply;
    return this;
  }

   /**
   * Circulating supply.
   * @return circulatingSupply
  **/
  @Schema(description = "Circulating supply.")
  public Float getCirculatingSupply() {
    return circulatingSupply;
  }

  public void setCirculatingSupply(Float circulatingSupply) {
    this.circulatingSupply = circulatingSupply;
  }

  public CryptoProfile logo(String logo) {
    this.logo = logo;
    return this;
  }

   /**
   * Logo image.
   * @return logo
  **/
  @Schema(description = "Logo image.")
  public String getLogo() {
    return logo;
  }

  public void setLogo(String logo) {
    this.logo = logo;
  }

  public CryptoProfile launchDate(String launchDate) {
    this.launchDate = launchDate;
    return this;
  }

   /**
   * Launch date.
   * @return launchDate
  **/
  @Schema(description = "Launch date.")
  public String getLaunchDate() {
    return launchDate;
  }

  public void setLaunchDate(String launchDate) {
    this.launchDate = launchDate;
  }

  public CryptoProfile proofType(String proofType) {
    this.proofType = proofType;
    return this;
  }

   /**
   * Proof type.
   * @return proofType
  **/
  @Schema(description = "Proof type.")
  public String getProofType() {
    return proofType;
  }

  public void setProofType(String proofType) {
    this.proofType = proofType;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    CryptoProfile cryptoProfile = (CryptoProfile) o;
    return Objects.equals(this.longName, cryptoProfile.longName) &&
        Objects.equals(this.name, cryptoProfile.name) &&
        Objects.equals(this.description, cryptoProfile.description) &&
        Objects.equals(this.website, cryptoProfile.website) &&
        Objects.equals(this.marketCap, cryptoProfile.marketCap) &&
        Objects.equals(this.totalSupply, cryptoProfile.totalSupply) &&
        Objects.equals(this.maxSupply, cryptoProfile.maxSupply) &&
        Objects.equals(this.circulatingSupply, cryptoProfile.circulatingSupply) &&
        Objects.equals(this.logo, cryptoProfile.logo) &&
        Objects.equals(this.launchDate, cryptoProfile.launchDate) &&
        Objects.equals(this.proofType, cryptoProfile.proofType);
  }

  @Override
  public int hashCode() {
    return Objects.hash(longName, name, description, website, marketCap, totalSupply, maxSupply, circulatingSupply, logo, launchDate, proofType);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class CryptoProfile {\n");
    
    sb.append("    longName: ").append(toIndentedString(longName)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    website: ").append(toIndentedString(website)).append("\n");
    sb.append("    marketCap: ").append(toIndentedString(marketCap)).append("\n");
    sb.append("    totalSupply: ").append(toIndentedString(totalSupply)).append("\n");
    sb.append("    maxSupply: ").append(toIndentedString(maxSupply)).append("\n");
    sb.append("    circulatingSupply: ").append(toIndentedString(circulatingSupply)).append("\n");
    sb.append("    logo: ").append(toIndentedString(logo)).append("\n");
    sb.append("    launchDate: ").append(toIndentedString(launchDate)).append("\n");
    sb.append("    proofType: ").append(toIndentedString(proofType)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
